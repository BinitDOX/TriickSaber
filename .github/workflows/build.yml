name: TriickSaber QPM Build

on:
  workflow_dispatch: # Allow manual trigger
    inputs:
      version:
        description: "Build Version (e.g., 0.1.0). Leave blank to use version from qpm.json for non-tag pushes."
        required: false
  push:
    tags:
      - "v[0-9]+.[0-9]+.[0-9]+" # Trigger on version tags like v0.1.0, v1.0.0, etc.
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  # Job to read information from qpm.json
  qpm_info:
    name: Read QPM Info
    runs-on: ubuntu-latest
    outputs:
      name: ${{ steps.read_qpm_info.outputs.name }}
      id: ${{ steps.read_qpm_info.outputs.id }}
      version: ${{ steps.read_qpm_info.outputs.version }}
      override_so_name: ${{ steps.read_qpm_info.outputs.override_so_name }}
      qmod_output_path: ${{ steps.read_qpm_info.outputs.qmod_output_path }}
      # NDK version from qpm.json will be used by qpm-action's resolve_ndk

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install jq (JSON processor)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Read info from qpm.json
        id: read_qpm_info
        shell: bash
        run: |
          QPM_FILE="qpm.json"
          if [ ! -f "$QPM_FILE" ]; then
            echo "$QPM_FILE not found!"
            exit 1
          fi
          NAME=$(jq -r '.info.name // "DefaultModName"' $QPM_FILE)
          ID=$(jq -r '.info.id // "DefaultModID"' $QPM_FILE)
          VERSION=$(jq -r '.info.version // "0.0.0"' $QPM_FILE)
          OVERRIDE_SO_NAME=$(jq -r '.info.additionalData.overrideSoName // "lib${ID}.so"' $QPM_FILE)
          QMOD_OUTPUT_PATH=$(jq -r '.workspace.qmodOutput // "${NAME}.qmod"' $QPM_FILE)

          echo "name=${NAME}" | tee -a "$GITHUB_OUTPUT"
          echo "id=${ID}" | tee -a "$GITHUB_OUTPUT"
          echo "version=${VERSION}" | tee -a "$GITHUB_OUTPUT"
          echo "override_so_name=${OVERRIDE_SO_NAME}" | tee -a "$GITHUB_OUTPUT"
          echo "qmod_output_path=${QMOD_OUTPUT_PATH}" | tee -a "$GITHUB_OUTPUT"
          echo "Read from qpm.json - Name: $NAME, ID: $ID, Version: $VERSION, SO: $OVERRIDE_SO_NAME, QMOD: $QMOD_OUTPUT_PATH"

  # Main build job
  build:
    name: Build Mod
    runs-on: ubuntu-latest
    needs: qpm_info # Depends on the qpm_info job completing successfully

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: true # Checkout submodules if your project uses them
          lfs: true       # Enable Git LFS if you use it for large assets
          fetch-depth: 0  # Fetch all history so tags are available for versioning

      - name: Setup Ninja
        uses: seanmiddleditch/gha-setup-ninja@v4 # Ensure Ninja is available for CMake

      - name: Extract Version from Tag or Input
        id: version_extraction
        shell: bash
        run: |
          FINAL_VERSION="${{ needs.qpm_info.outputs.version }}" # Default to version from qpm.json
          TAG_NAME=""

          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref_type }}" == "tag" ]]; then
            TAG_NAME="${GITHUB_REF#refs/tags/}"
            # Assuming tag is 'vX.Y.Z' or 'X.Y.Z'
            FINAL_VERSION=$(echo "$TAG_NAME" | sed 's/^v//')
            echo "Using version from tag: $FINAL_VERSION"
          elif [ -n "${{ github.event.inputs.version }}" ]; then
            FINAL_VERSION="${{ github.event.inputs.version }}"
            echo "Using version from manual input: $FINAL_VERSION"
          else
            echo "Using version from qpm.json: $FINAL_VERSION"
          fi

          # Ensure version is in X.Y.Z format for qpm.json update if needed later by scripts
          # This is a simple check; more robust semver parsing might be needed if formats vary wildly
          if ! [[ "$FINAL_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+([+-].*)?$ ]]; then
            echo "Warning: Extracted version '$FINAL_VERSION' does not strictly match X.Y.Z. Using as is."
          fi

          echo "tag_name=${TAG_NAME}" | tee -a "$GITHUB_OUTPUT"
          echo "final_version=${FINAL_VERSION}" | tee -a "$GITHUB_OUTPUT"

      - name: Update version in project files
        if: steps.version_extraction.outputs.final_version != needs.qpm_info.outputs.version # Only run if version changes
        shell: bash
        run: |
          VERSION_TO_SET="${{ steps.version_extraction.outputs.final_version }}"
          echo "Setting version in files to: $VERSION_TO_SET"
          if [ -f qpm.json ]; then
            jq --arg v "$VERSION_TO_SET" '.info.version = $v' qpm.json > qpm.json.tmp && mv qpm.json.tmp qpm.json
          fi
          if [ -f mod.template.json ]; then # Assuming your createqmod.ps1 uses this
             jq --arg v "$VERSION_TO_SET" '.version = $v' mod.template.json > mod.template.json.tmp && mv mod.template.json.tmp mod.template.json
          fi
        env:
          JQ_VERSION: ${{ steps.version_extraction.outputs.final_version }} # For potential jq script usage

      - name: Setup QPM, Restore Deps, and Resolve NDK
        uses: fernthedev/qpm-action@v1
        with:
          workflow_token: ${{ secrets.GITHUB_TOKEN }}
          restore: true
          resolve_ndk: true
          cache: true

      - name: Build shared library (.so)
        shell: pwsh # Assuming your build.ps1 is PowerShell
        run: ./scripts/build.ps1

      - name: Create .qmod package
        shell: pwsh # Assuming your createqmod.ps1 is PowerShell
        # Pass the determined qmod output name to the script
        run: ./scripts/createqmod.ps1 -qmodName "${{ needs.qpm_info.outputs.name }}"
        # If createqmod.ps1 uses the version for the qmod filename, ensure it can access it.
        # The version might be in mod.template.json now.

      - name: Rename artifacts for consistency
        shell: bash
        run: |
          SO_NAME="${{ needs.qpm_info.outputs.override_so_name }}"
          QMOD_ACTUAL_OUTPUT_NAME="${{ needs.qpm_info.outputs.name }}.qmod" # Assuming createqmod.ps1 uses this name

          # Check if files exist before moving
          if [ -f "./build/$SO_NAME" ]; then mv "./build/$SO_NAME" "./$SO_NAME"; fi
          if [ -f "./build/debug/$SO_NAME" ]; then mv "./build/debug/$SO_NAME" "./debug_$SO_NAME"; fi
          # The qmod name might already be correct if createqmod.ps1 uses needs.qpm_info.outputs.name
          echo "Expected qmod: $QMOD_ACTUAL_OUTPUT_NAME"
          ls -l

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: TriickSaber-Build-${{ steps.version_extraction.outputs.final_version }} # Include version in artifact name
          if-no-files-found: error # Fail if any specified path is not found
          path: |
            ${{ needs.qpm_info.outputs.override_so_name }}
            debug_${{ needs.qpm_info.outputs.override_so_name }}
            ${{ needs.qpm_info.outputs.name }}.qmod
          retention-days: 7 # Keep artifacts for 7 days